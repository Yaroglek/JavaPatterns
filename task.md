# Задания

## Задание 2. Singleton

### Описание

Класс [`Logger`](./src/main/java/org/yaroglek/patterns/extern/logger/Logger.java) реализует паттерн проектирования Singleton.

### Причина выбора паттерна Singleton для данного класса

Паттерн Singleton гарантирует наличие лишь одного экземпляра `Logger` в приложении, так как нет особого смысла иметь несколько экземпляров для операций логгирования.

### Признаки реализации Singleton в данном классе

Присутствует приватный конструктор, static поле instance и статичный метод доступа к нему.


## Задание 3. Prototype

### Описание

Классы [`Survey`](./src/main/java/org/yaroglek/patterns/domain/Survey.java), [`Question`](./src/main/java/org/yaroglek/patterns/domain/Question.java) и [`Option`](./src/main/java/org/yaroglek/patterns/domain/Option.java) реализуют паттерн проектирования Prototype.

### Причина выбора паттерна Prototype для данных классов

Паттерн Prototype позволяет создавать новые объекты путем копирования существующего объекта. Реализация паттерна Prototype в классах `Survey`, `Question` и `Option` позволяет создавать глубокие копии данных объектов, если, например, необходима копия опроса, с которой в дальнейшем будут проводить какие-либо манипуляции.

### Признаки реализации Prototype в данных классах

Присутствует копирующий конструктор, присваивающий данному объекту все поля из аргумента. Копирование глубокое, т.к. поля являются либо String или enum (immutable), либо, если это списки, происходит копирование каждого объекта в списке через его копирующий конструктор.


## Задание 4. SFM

### Описание

Класс [`Question`](./src/main/java/org/yaroglek/patterns/domain/Question.java) реализует паттерн проектирования Static Factory Method.

### Причина выбора паттерна SFM для данного класса

Паттерн Static Factory Method предлагает использование статичных методов для создания экземпляров класса вместо конструкторов, что повышает читабельность кода, а также инкапсулирует сложную логику, необходимую для предварительного построения. В классе `Question` SFM используется для создания базового "полярного" вопроса, имеющего только 2 варианта ответа - Да или Нет.

### Признаки реализации SFM в данном классе

Присутствует static метод, возвращающий экземпляр данного класса и содержащий в себе определенную логику построения.


## Задание 5. Builder

### Описание

Класс [`User`](./src/main/java/org/yaroglek/patterns/domain/User.java) реализует паттерн проектирования Builder.

### Причина выбора паттерна Builder для данного класса

Паттерн Builder позволяет удобно создавать сложные объекты с помощью четко определенной последовательности действий и решает проблему большого количества необязательных параметров. Применив этот паттерн к классу `User`, стало возможным удобно создавать объекты данного класса, применяя fluent-style.

### Признаки реализации Builder в данном классе

В классе User присутствует метод builder, возвращающий объект вложенного статического класса UserBuilder, который содержит поля, аналогичные полям во внешнем классе, и набор методов, принимающих некоторое значение в качестве аргумента и возвращающих данный экземпляр вложенного класса с помощью this.


## Задание 8. Adapter

### Описание

Класс [`CountryCodeServiceAdapter`](./src/main/java/org/yaroglek/patterns/app/service/countrycode/CountryCodeServiceAdapter.java) реализует паттерн проектирования Adapter.

### Причина выбора паттерна Adapter для данного класса

Паттерн Adapter позволяет объектам с несовместимыми интерфейсами работать вместе, трансформируя интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. Таким образом мы скрываем сложность работы с API restcountries и обеспечиваем совместимость м/у интерфейсом `CountryCodeService` и классом `RestCountriesApiImpl`.


## Задание 11. Decorator

### Описание

Реализацией паттерна Decorator является класс [`SurveyDecorator`](./src/main/java/org/yaroglek/patterns/app/service/surveyservice/SurveyDecorator.java) (абстрактный декоратор) и другие классы в этом пакете, а именно: `SurveyService` - компонент, `SurveyServiceImpl` - конкретный компонент, `LoggedSurveyService` - конкретный декоратор.

### Причина выбора паттерна Decorator для данного класса

Паттерн Decorator позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». В данном случае есть сервис `SurveyServiceImpl`, который выполняет стандартные операции создания, получения и удаления. Добавление логирования времени выполнения каждой операции может быть сделано без изменения внутренней логики этих методов.

### Признаки реализации Decorator в данном классе

Присутствует полный комплект классов и интерфейсов, необходимый для паттерна: компонент и его конкретная реализация, абстрактный декоратор, реализующий интерфейс компонента и также содержащий его в себе (композиция), и его конкретная реализация.


## Задание 16. Iterator

### Описание 

Реализацией паттерна Iterator является класс [`SurveyIterator`](./src/main/java/org/yaroglek/patterns/domain/iterator/QuestionIterator.java) (конкретный итератор), а также интерфейс `SurveyIterator` и метод getQuestionIterator в классе `Survey`.
 
### Причина выбора паттерна Iterator для данного класса

Паттерн Iterator позволяет осуществлять последовательный обход сложной структуры данных, не раскрывая ее внутренние детали. В данном случае `QuestionIterator` позволяет удобно итерироваться по списку в опросе.

### Признаки реализации Iterator в данном классе

Присутствует полный комплект классов и интерфейсов, необходимый для паттерна: интерфейс итератора, конкретный итератор, фабрика для создания итератора


## Задание 22. State

### Описание

Реализацией паттерна State является класс [`Survey`](./src/main/java/org/yaroglek/patterns/domain/Survey.java) (контекст), интерфейс [`SurveyState`](./src/main/java/org/yaroglek/patterns/domain/state/SurveyState.java), а также конкретные реализации в том же пакете, что и интерфейс.

### Причина выбора паттерна Iterator для данного класса

Паттерн State позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта. В данном случае `Survey` может иметь несколько состояний: черновик, опубликован, завершен, архивирован. Таким образом происходит делегация работы состояниям. Поведение контекста можно будет изменить в любой момент, подключив к нему другое состояние.

### Признаки реализации Iterator в данном классе

Присутствует полный комплект классов и интерфейсов, необходимый для паттерна: интерфейс состояния, конкретные состояния, контекст, поле state в контексте, метод changeState в контексте.


## Задание 23. Strategy

### Описание

Реализацией паттерна Strategy является интерфейс [`ResultCalculationStrategy`](./src/main/java/org/yaroglek/patterns/app/service/strategy/ResultCalculationStrategy.java), конкретные реализации в том же пакете и контекст [`SurveyResultService`](./src/main/java/org/yaroglek/patterns/app/service/strategy/SurveyResultService.java).

### Причина выбора паттерна Iterator для данного класса

Паттерн Strategy выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми. Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект другим, если требуется иной способ решения задачи. В данном случае контекст `SurveyResultService` хранит ссылку на объект конкретной стратегии, работая с ним через общий интерфейс стратегий, и имеет возможность заменить стратегию через сеттер, тем самым делегирую работу объекту стратегии.

### Признаки реализации Iterator в данном классе

Присутствует полный комплект классов и интерфейсов, необходимый для паттерна: интерфейс стратегии, конкретные стратегии, класс контекста, поле strategy в контексте, метод setStrategy.


## Задание 24. Template Method

### Описание

Реализацией паттерна Template Method является абстрактный класс [`SurveyAnalysis`](./src/main/java/org/yaroglek/patterns/app/service/templatemethod/SurveyAnalysis.java) и конкретные реализации в том же пакете.

### Причина выбора паттерна Template Method для данного класса

Паттерн Template Method определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры. В данном случае абстрактный класс `SurveyAnalysis` определяет общий алгоритм анализа ответов на опрос, а конкретные реализации переопределяют основной метод обработки ответов.

### Признаки реализации Template Method в данном классе

Присутствует полный комплект классов, необходимый для паттерна: абстрактный класс с final методом, определяющим алгоритм обработки, и одним абстрактным методов, призванным определять тип анализа, а также 2 конкретные реализации, переопределяющие этот метод.
